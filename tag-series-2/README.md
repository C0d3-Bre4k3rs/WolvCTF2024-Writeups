
# Crypto: tag-series-2
solver: [N04M1st3r](https://github.com/N04M1st3r)  
writeup-writer: [L3d](https://github.com/imL3d)   
___
**Author:** retu2libc  
**Description:**
> Don't worry, the interns wrote this one.  
**files (copy):** [chal.py](files/chal.py)  

## Solution

### Preview

*It is recommended to read the [first challenge](https://github.com/C0d3-Bre4k3rs/WolvCTF2024-Writeups/tree/main/tag-series-1) in this series before reading this one.*

This challenge is very similar to the first one; we need to input a plaintext string and a guess to the last block of it's AES (CBC) encryption 4 times in a row - if one of those guesses match we get the flag.  

The differences from the first challenge:
1. AES encryption with mode CBC is used, instead of ECB.
2. We get 4 tries instead of 3.
3. To each plaintext given it's length is being added to the end before the encryption. 
4. The plaintext to get the flag needs to start with a shorter string: `"GET: flag.txt"`

And again, before we will showcase the solution, an understanding of how the `AES CBC` mode works is needed, so we can properly try and exploit this algorithm and it's usecase.  

### AES (CBC) mode

The CBC mode fixes some of the problems with the lack of *cryptographic diffusion* that EBC mode had. Instead of each plaintext block being enciphered on its own, it is being XORed with the previous ciphertext, and only then being encrypted (the first block is being XORed with a random Initialization Vector), as shown in the image below:  

<img src="_images/cbc.png" alt="CBC Encryption" width="700"/>

Again, for our purposes in the tag-series challenges, we don't really need to know much about the [Block Cipher algorithm](https://en.wikipedia.org/wiki/Block_cipher), apart from it being a *deterministic algorithm*, meaning that if we give it the same key and the same input, it will always give us the same output.  
  
The change from `ECB` mode to `CBC` mode fixes the exploit we used at the previous challenge - because each part affects the following one it seems as though we cannot have two different plaintexts produce the same result.    

### The exploit

At first glance, this challenge seems very discouraging - we need to find two differnet plaintext inputs that will give us the same last block of ciphertext, but every little change in the previous blocks affects the outcome!    
After looking further at the `CBC` mode of encryption and the given restrictions, we can come to 3 subtle but important realizations:  
1. The same 2 inputs to the XOR and then the Block Encryption, will yield the same ciphertext.  
2. It **is** possible to get the same last block of ciphertext from two different plaintexts, we just have to make sure the two inputs to that "part of the chain" are the same (take a look at the illustartaion below).
3. The two plaintexts that will yield the same result will have the same length, since the last block of the plaintext needs to be the same (and the length of the plaintext is the last block).

<img src="_images/illu1.png" alt="Illu1" width="500"/>
  
Because the last block will always contain the legth, our goal is to try and create the same ciphertext of the block that came before it (becaues it's the other part of the XOR), with two different plaintext inputs.  
For this, we have to do some sort of computation. XOR is commutative operation, we can leverage this fact to our advantage.  
For example, as shown in the illustartion below, both the blocks of ciphertexts generated by `1)` and `2)` will be the same.  

<img src="_images/illu2.png" alt="Illu2" width="700"/>

So, the only thing left to do is just find a way to get `A` and `B`, and to put the pieces together!  
  
As it happens, the first part is really easy - we have four tries that we can use in order to compute A, and B.
The ciphertext we will send is `our_input + LENGTH`. And both A, and B will be the last block of the ciphertext resulted by this.  
Then we just need to recreate the terms that allowed the cratoin of A or B at the first time then add the other ciphertext we didn't create. This will give us the result we want to send the next time!  
For the second time we want to do the same, but swapped. This will equal the same last block of ciphertext we recieved at the previous try... And bingo!  
